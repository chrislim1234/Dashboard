import { defineComponent as ee, reactive as Le, computed as m, watch as Fe, openBlock as v, createElementBlock as y, normalizeClass as Y, unref as d, renderSlot as C, createElementVNode as b, createCommentVNode as _, Fragment as H, renderList as N, toDisplayString as S, withModifiers as P, normalizeStyle as Ae, createTextVNode as Ye } from "vue";
const w = () => B(new Date()), Te = (e, n, a) => {
  switch (n) {
    case "year":
      return new Date(e.getFullYear(), 0);
    case "month":
      return new Date(e.getFullYear(), e.getMonth());
    case "week":
      return q(e, a);
    default:
      return e;
  }
}, we = (e) => [...Array(7)].map((n, a) => I(e, a)), I = (e, n) => new Date(e.getFullYear(), e.getMonth(), e.getDate() + n, e.getHours(), e.getMinutes(), e.getSeconds()), q = (e, n) => I(e, (n - e.getDay() - 7) % -7), We = (e, n) => I(q(e, n), 7), T = (e) => new Date(e.getFullYear(), e.getMonth()), $e = (e) => Math.ceil(e.getDate() / 7), He = (e, n, a) => new Date(e.getFullYear() + (n == "year" ? a : 0), e.getMonth() + (n == "month" ? a : 0), e.getDate() + (n == "week" ? a * 7 : 0)), G = (e) => ("0" + String(e.getMonth() + 1)).slice(-2), Q = (e) => ("0" + String(e.getDate())).slice(-2), te = (e) => e.getFullYear() + "-" + G(e), Ne = (e) => te(e) + "-" + Q(e), Be = (e) => G(e) + "-" + Q(e), Ee = (e, n, a) => {
  if (e.getHours() === 0 && e.getMinutes() === 0 && e.getSeconds() === 0)
    return "";
  if (!E()) {
    var l = new Date().getTimezoneOffset() * 6e4;
    return new Date(e.getTime() - l).toISOString().slice(11, 16);
  }
  return e.toLocaleTimeString(n, a);
}, xe = (e, n, a, l) => {
  const c = e.getFullYear() === n.getFullYear(), h = ne(e, n), M = !(a === "year") && !(a === "month");
  let g = [];
  return g.push(l[e.getMonth()]), M && (g.push(" "), g.push(e.getDate())), c || (g.push(M ? ", " : " "), g.push(e.getFullYear())), !h || !c ? (g.push(" \u2013 "), h || g.push(l[n.getMonth()]), M && g.push(" ")) : M && g.push(" \u2013 "), M ? (g.push(n.getDate()), g.push(", ")) : g.push(" "), g.push(n.getFullYear()), g.join("");
}, ae = (e, n) => {
  const a = Date.UTC(n.getFullYear(), n.getMonth(), n.getDate()), l = Date.UTC(e.getFullYear(), e.getMonth(), e.getDate());
  return (a - l) / 864e5;
}, Ue = (e, n) => e && n && ae(e, n) === 0, Re = (e, n) => e && n && e.getTime() === n.getTime(), ne = (e, n) => e && n && e.getFullYear() === n.getFullYear() && e.getMonth() === n.getMonth(), Ve = (e) => T(e) < T(w()), je = (e) => T(e) > T(w()), ze = (e) => B(e) > w(), qe = (e) => B(e) < w(), Ge = (e) => e.getMonth() !== I(e, 7).getMonth(), Qe = (e) => e.getMonth() !== I(e, 1).getMonth(), re = (e) => {
  let n = [...Array(7)].map((a) => 0);
  return e.split(/\D/, 7).forEach((a, l) => n[l] = Number(a)), n[1]--, new Date(n[0], n[1], n[2], n[3], n[4], n[5], n[6]);
}, z = (e) => typeof e == "string" ? re(e) : new Date(e), B = (e) => {
  const n = new Date(e);
  return n.setHours(0, 0, 0, 0), n;
}, Je = (e) => e.substring(0, 2), E = () => typeof Intl < "u", Ke = (e, n) => {
  if (!E())
    return [...Array(12)].map((l) => "");
  const a = new Intl.DateTimeFormat(e, { month: n });
  return [...Array(12)].map((l, c) => a.format(new Date(2017, c, 1)));
}, Xe = (e, n, a) => {
  if (!E())
    return [...Array(7)].map((c) => "");
  const l = new Intl.DateTimeFormat(e, { weekday: n });
  return [...Array(7)].map((c, h) => l.format(new Date(2017, 0, (h + 1 + a) % 7)));
}, Ze = () => typeof navigator > "u" ? "unk" : (navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language).toLowerCase(), _e = (e, n) => {
  const a = e.classes ? [...e.classes] : [];
  return n && a.push("isHovered"), {
    originalItem: e,
    startDate: z(e.startDate),
    endDate: z(e.endDate || e.startDate),
    classes: a,
    title: e.title || "Untitled",
    id: e.id,
    url: e.url
  };
}, r = {
  addDays: I,
  beginningOfMonth: T,
  beginningOfPeriod: Te,
  beginningOfWeek: q,
  dateOnly: B,
  dayDiff: ae,
  daysOfWeek: we,
  endOfWeek: We,
  formattedPeriod: xe,
  formattedTime: Ee,
  fromIsoStringToLocalDate: re,
  getDefaultBrowserLocale: Ze,
  getFormattedMonthNames: Ke,
  getFormattedWeekdayNames: Xe,
  incrementPeriod: He,
  instanceOfMonth: $e,
  isFutureMonth: je,
  isInFuture: ze,
  isInPast: qe,
  isLastDayOfMonth: Qe,
  isLastInstanceOfMonth: Ge,
  isoMonthDay: Be,
  isoYearMonth: te,
  isoYearMonthDay: Ne,
  isPastMonth: Ve,
  isSameDate: Ue,
  isSameDateTime: Re,
  isSameMonth: ne,
  languageCode: Je,
  normalizeItem: _e,
  paddedDay: Q,
  paddedMonth: G,
  supportsIntl: E,
  today: w,
  toLocalDate: z
};
class et {
  constructor() {
    this.currentDragItem = null, this.dateSelectionOrigin = null, this.currentHoveredItemId = "", this.CalendarMath = r;
  }
}
const tt = { class: "cv-header-days" }, at = {
  key: 0,
  class: "cv-weeknumber"
}, nt = ["aria-multiselectable"], rt = {
  key: 0,
  class: "cv-weeknumber"
}, st = { class: "cv-weekdays" }, ot = ["draggable", "aria-grabbed", "aria-label", "aria-selected", "aria-dropeffect", "onClick", "onDragstart", "onDrop", "onDragover", "onDragenter", "onDragleave"], it = { class: "cv-day-number" }, lt = ["draggable", "aria-grabbed", "title", "onDragstart", "onMouseenter", "onMouseleave", "onClick", "innerHTML"], ht = /* @__PURE__ */ ee({
  __name: "CalendarView",
  props: {
    showDate: { type: Date, default: void 0 },
    displayPeriodUom: { type: String, default: "month" },
    displayPeriodCount: { type: Number, default: 1 },
    displayWeekNumbers: { type: Boolean, default: !1 },
    locale: { type: String, default: void 0 },
    monthNameFormat: { type: String, default: "long" },
    weekdayNameFormat: { type: String, default: "short" },
    showTimes: { type: Boolean, default: !1 },
    timeFormatOptions: { type: Object, default: () => {
    } },
    disablePast: { type: Boolean, default: !1 },
    disableFuture: { type: Boolean, default: !1 },
    enableDateSelection: { type: Boolean, default: !1 },
    selectionStart: { type: Date, default: null },
    selectionEnd: { type: Date, default: null },
    enableDragDrop: { type: Boolean, default: !1 },
    startingDayOfWeek: { type: Number, default: 0 },
    items: { type: Array, default: () => [] },
    dateClasses: { type: Object, default: () => {
    } },
    itemTop: { type: String, default: "1.4em" },
    itemContentHeight: { type: String, default: "1.4em" },
    itemBorderHeight: { type: String, default: "2px" },
    periodChangedCallback: { type: Function, default: void 0 },
    currentPeriodLabel: { type: String, default: "" },
    currentPeriodLabelIcons: { type: String, default: "\u21E4-\u21E5" },
    doEmitItemMouseEvents: { type: Boolean, default: !1 }
  },
  emits: [
    "input",
    "period-changed",
    "click-date",
    "click-item",
    "item-mouseenter",
    "item-mouseleave",
    "drag-start",
    "drag-over-date",
    "drag-enter-date",
    "drag-leave-date",
    "drop-on-date",
    "date-selection",
    "date-selection-start",
    "date-selection-finish"
  ],
  setup(e, { emit: n }) {
    const a = e, l = Le(new et()), c = m(() => a.locale || r.getDefaultBrowserLocale()), h = m(() => a.showDate ? r.dateOnly(a.showDate) : r.today()), D = m(() => r.beginningOfPeriod(h.value, a.displayPeriodUom, a.startingDayOfWeek)), L = m(
      () => r.addDays(r.incrementPeriod(D.value, a.displayPeriodUom, a.displayPeriodCount), -1)
    ), M = m(() => {
      const t = r.beginningOfWeek(r.beginningOfPeriod(D.value, "year", 0), a.startingDayOfWeek), s = r.beginningOfWeek(D.value, a.startingDayOfWeek);
      return 1 + Math.floor(r.dayDiff(t, s) / 7);
    }), g = m(() => r.beginningOfWeek(D.value, a.startingDayOfWeek)), x = m(() => r.endOfWeek(L.value, a.startingDayOfWeek)), se = m(() => {
      const t = Math.floor((r.dayDiff(g.value, x.value) + 1) / 7);
      return [...Array(t)].map((s, i) => r.addDays(g.value, i * 7));
    }), U = m(() => r.getFormattedMonthNames(c.value, a.monthNameFormat)), oe = m(() => r.getFormattedWeekdayNames(c.value, a.weekdayNameFormat, a.startingDayOfWeek)), R = m(() => a.items ? a.items.map((t) => r.normalizeItem(t, t.id === l.currentHoveredItemId)) : []), V = m(() => r.beginningOfPeriod(r.today(), a.displayPeriodUom, a.startingDayOfWeek)), ie = m(
      () => r.addDays(r.incrementPeriod(V.value, a.displayPeriodUom, a.displayPeriodCount), -1)
    ), le = m(() => r.formattedPeriod(D.value, L.value, a.displayPeriodUom, U.value)), de = m(() => {
      const t = V.value, s = D.value;
      return a.currentPeriodLabel ? a.currentPeriodLabel === "icons" ? a.currentPeriodLabelIcons[Math.sign(t.getTime() - s.getTime()) + 1] : a.currentPeriodLabel : r.formattedPeriod(t, ie.value, a.displayPeriodUom, U.value);
    }), ue = m(
      () => ({
        previousYear: k(-12),
        previousPeriod: k(-1),
        nextPeriod: k(1),
        previousFullPeriod: k(-a.displayPeriodCount),
        nextFullPeriod: k(a.displayPeriodCount),
        nextYear: k(12),
        currentPeriod: V.value,
        currentPeriodLabel: de.value,
        periodStart: D.value,
        periodEnd: L.value,
        displayLocale: c.value,
        displayFirstDate: g.value,
        displayLastDate: x.value,
        monthNames: U.value,
        fixedItems: R.value,
        periodLabel: le.value
      })
    ), ce = m(() => ({
      periodStart: D,
      periodEnd: L,
      displayFirstDate: g,
      displayLastDate: x
    }));
    Fe(
      () => ce,
      (t) => {
        a.periodChangedCallback && (n("period-changed"), a.periodChangedCallback(t, "watch"));
      },
      { immediate: !0, deep: !0 }
    );
    const ge = (t, s) => {
      a.disablePast && r.isInPast(t) || a.disableFuture && r.isInFuture(t) || n("click-date", t, J(t, t), s);
    }, fe = (t, s) => n("click-item", t, s), F = (t) => "dow" + (t + a.startingDayOfWeek) % 7, k = (t) => {
      const s = r.incrementPeriod(D.value, a.displayPeriodUom, t), i = r.incrementPeriod(s, a.displayPeriodUom, a.displayPeriodCount);
      return a.disablePast && i <= r.today() || a.disableFuture && s > r.today() ? null : s;
    }, me = (t, s) => {
      l.currentHoveredItemId = t.id, a.doEmitItemMouseEvents && n("item-mouseenter", t, s);
    }, De = (t, s) => {
      l.currentHoveredItemId = "", a.doEmitItemMouseEvents && n("item-mouseleave", t, s);
    }, pe = (t, s) => {
      var f, o;
      if (!a.enableDateSelection)
        return !1;
      (f = s.dataTransfer) == null || f.setData("text", t.toString());
      let i = new Image();
      return i.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==", (o = s.dataTransfer) == null || o.setDragImage(i, 10, 10), l.dateSelectionOrigin = t, j("date-selection-start", t, s), !0;
    }, he = (t, s) => {
      var i;
      return a.enableDragDrop ? ((i = s.dataTransfer) == null || i.setData("text", t.id), l.currentDragItem = t, l.dateSelectionOrigin = null, n("drag-start", t, s), !0) : !1;
    }, W = (t, s, i) => a.enableDragDrop ? (n(t, l.currentDragItem, s, i), !0) : !1, ve = (t, s) => {
      W("drag-over-date", t, s);
    }, ye = (t, s) => {
      if (a.enableDateSelection && l.dateSelectionOrigin) {
        j("date-selection", t, s);
        return;
      }
      if (!W("drag-enter-date", t, s))
        return;
      s.target.classList.add("draghover");
    }, be = (t, s) => {
      if (a.enableDateSelection && a.selectionStart || !W("drag-leave-date", t, s))
        return;
      s.target.classList.remove("draghover");
    }, Pe = (t, s) => {
      if (a.enableDateSelection && l.dateSelectionOrigin) {
        j("date-selection-finish", t, s);
        return;
      }
      if (!W("drop-on-date", t, s))
        return;
      s.target.classList.remove("draghover");
    }, j = (t, s, i) => {
      !l.dateSelectionOrigin || n(t, s <= l.dateSelectionOrigin ? [s, l.dateSelectionOrigin, i] : [l.dateSelectionOrigin, s, i]);
    }, Me = (t, s) => t.startDate < s.startDate ? -1 : s.startDate < t.startDate ? 1 : t.endDate > s.endDate ? -1 : s.endDate > t.endDate ? 1 : t.id < s.id ? -1 : 1, Se = (t) => J(t, r.addDays(t, 6)), J = (t, s) => R.value.filter((i) => i.endDate >= t && r.dateOnly(i.startDate) <= s, this).sort(Me), Oe = (t) => !!R.value.find((s) => s.endDate >= t && r.dateOnly(s.startDate) <= t), K = (t) => !(!a.selectionStart || !a.selectionEnd || t < r.dateOnly(a.selectionStart) || t > r.dateOnly(a.selectionEnd)), ke = (t) => {
      const s = Se(t), i = [], f = [[], [], [], [], [], [], []];
      for (let o = 0; o < s.length; o++) {
        const u = Object.assign({}, s[o], {
          classes: [...s[o].classes],
          itemRow: 0
        }), p = u.startDate < t, A = p ? 0 : r.dayDiff(t, u.startDate), Z = Math.min(7 - A, r.dayDiff(r.addDays(t, A), u.endDate) + 1);
        p && u.classes.push("continued"), r.dayDiff(t, u.endDate) > 6 && u.classes.push("toBeContinued"), r.isInPast(u.endDate) && u.classes.push("past"), u.originalItem.url && u.classes.push("hasUrl");
        for (let O = 0; O < 7; O++)
          if (O === A) {
            let $ = 0;
            for (; f[O][$]; )
              $++;
            u.itemRow = $, f[O][$] = !0;
          } else
            O < A + Z && (f[O][u.itemRow] = !0);
        u.classes.push(`offset${A}`), u.classes.push(`span${Z}`), i.push(u);
      }
      return i;
    }, Ce = (t) => {
      const s = '<span class="startTime">' + r.formattedTime(t.startDate, c.value, a.timeFormatOptions) + "</span>";
      let i = "";
      return r.isSameDateTime(t.startDate, t.endDate) || (i = '<span class="endTime">' + r.formattedTime(t.endDate, c.value, a.timeFormatOptions) + "</span>"), s + i;
    }, Ie = (t) => a.showTimes ? Ce(t) + " " + t.title : t.title, X = (t) => {
      const s = t.itemRow, i = a.itemContentHeight, f = a.itemBorderHeight;
      return `calc(${a.itemTop} + ${s}*${i} + ${s}*${f})`;
    };
    return (t, s) => (v(), y("div", {
      "aria-label": "Calendar",
      class: Y([
        "cv-wrapper",
        "locale-" + d(r).languageCode(d(c)),
        "locale-" + d(c),
        "y" + d(D).getFullYear(),
        "m" + d(r).paddedMonth(d(D)),
        "period-" + e.displayPeriodUom,
        "periodCount-" + e.displayPeriodCount,
        {
          past: d(r).isPastMonth(d(D)),
          future: d(r).isFutureMonth(d(D)),
          noIntl: !d(r).supportsIntl
        }
      ])
    }, [
      C(t.$slots, "header", { headerProps: d(ue) }),
      b("div", tt, [
        e.displayWeekNumbers ? (v(), y("div", at)) : _("", !0),
        (v(!0), y(H, null, N(d(oe), (i, f) => C(t.$slots, "dayHeader", {
          index: F(f),
          label: i
        }, () => [
          (v(), y("div", {
            key: F(f),
            class: Y([F(f), "cv-header-day"])
          }, S(i), 3))
        ])), 256))
      ]),
      b("div", {
        "aria-multiselectable": e.enableDateSelection,
        class: "cv-weeks"
      }, [
        (v(!0), y(H, null, N(d(se), (i, f) => (v(), y("div", {
          key: `${f}-week`,
          class: Y(["cv-week", "week" + (f + 1), "ws" + d(r).isoYearMonthDay(i)])
        }, [
          e.displayWeekNumbers ? (v(), y("div", rt, [
            C(t.$slots, "weekNumber", {
              date: i,
              numberInYear: d(M) + f,
              numberInPeriod: f + 1
            }, () => [
              b("span", null, S(d(M) + f), 1)
            ])
          ])) : _("", !0),
          b("div", st, [
            (v(!0), y(H, null, N(d(r).daysOfWeek(i), (o, u) => (v(), y("div", {
              key: F(u),
              draggable: e.enableDateSelection,
              class: Y([
                "cv-day",
                F(u),
                "d" + d(r).isoYearMonthDay(o),
                "d" + d(r).isoMonthDay(o),
                "d" + d(r).paddedDay(o),
                "instance" + d(r).instanceOfMonth(o),
                {
                  today: d(r).isSameDate(o, d(r).today()),
                  outsideOfMonth: !d(r).isSameMonth(o, d(h)),
                  past: d(r).isInPast(o),
                  future: d(r).isInFuture(o),
                  last: d(r).isLastDayOfMonth(o),
                  lastInstance: d(r).isLastInstanceOfMonth(o),
                  hasItems: Oe(o),
                  selectionStart: d(r).isSameDate(o, e.selectionStart),
                  selectionEnd: d(r).isSameDate(o, e.selectionEnd)
                },
                ...e.dateClasses && e.dateClasses[d(r).isoYearMonthDay(o)] || []
              ]),
              "aria-grabbed": e.enableDateSelection ? K(o) : void 0,
              "aria-label": o.getDate().toString(),
              "aria-selected": K(o),
              "aria-dropeffect": e.enableDragDrop && l.currentDragItem ? "move" : e.enableDateSelection && l.dateSelectionOrigin ? "execute" : "none",
              onClick: (p) => ge(o, p),
              onDragstart: (p) => pe(o, p),
              onDrop: P((p) => Pe(o, p), ["prevent"]),
              onDragover: P((p) => ve(o, p), ["prevent"]),
              onDragenter: P((p) => ye(o, p), ["prevent"]),
              onDragleave: P((p) => be(o, p), ["prevent"])
            }, [
              b("div", it, S(o.getDate()), 1),
              C(t.$slots, "dayContent", { day: o })
            ], 42, ot))), 128)),
            (v(!0), y(H, null, N(ke(i), (o) => C(t.$slots, "item", {
              value: o,
              weekStartDate: i,
              top: X(o)
            }, () => [
              (v(), y("div", {
                key: o.id,
                draggable: e.enableDragDrop,
                "aria-grabbed": e.enableDragDrop ? o == l.currentDragItem : void 0,
                class: Y([o.classes, "cv-item"]),
                title: o.tooltip || o.title,
                style: Ae(`top:${X(o)};${o.originalItem.style}`),
                onDragstart: (u) => he(o, u),
                onMouseenter: (u) => me(o, u),
                onMouseleave: (u) => De(o, u),
                onClick: P((u) => fe(o, u), ["stop"]),
                innerHTML: Ie(o)
              }, null, 46, lt))
            ])), 256))
          ])
        ], 2))), 128))
      ], 8, nt)
    ], 2));
  }
});
const dt = { class: "cv-header" }, ut = { class: "cv-header-nav" }, ct = ["disabled"], gt = ["disabled", "innerHTML"], ft = ["disabled"], mt = ["disabled"], Dt = { class: "periodLabel" }, vt = /* @__PURE__ */ ee({
  __name: "CalendarViewHeader",
  props: {
    headerProps: {
      type: Object,
      required: !0
    },
    previousYearLabel: { type: String, default: "<<" },
    previousPeriodLabel: { type: String, default: "<" },
    nextPeriodLabel: { type: String, default: ">" },
    nextYearLabel: { type: String, default: ">>" }
  },
  emits: ["input"],
  setup(e, { emit: n }) {
    const a = (l) => n("input", l);
    return (l, c) => (v(), y("div", dt, [
      b("div", ut, [
        b("button", {
          disabled: !e.headerProps.previousYear,
          class: "previousYear",
          "aria-label": "Previous Year",
          onClick: c[0] || (c[0] = P((h) => a(e.headerProps.previousYear), ["prevent"]))
        }, S(e.previousYearLabel), 9, ct),
        b("button", {
          disabled: !e.headerProps.previousPeriod,
          class: "previousPeriod",
          "aria-label": "Previous Period",
          onClick: c[1] || (c[1] = P((h) => a(e.headerProps.previousPeriod), ["prevent"])),
          innerHTML: e.previousPeriodLabel
        }, null, 8, gt),
        b("button", {
          class: "currentPeriod",
          "aria-label": "Current Period",
          onClick: c[2] || (c[2] = P((h) => a(e.headerProps.currentPeriod), ["prevent"]))
        }, S(e.headerProps.currentPeriodLabel), 1),
        b("button", {
          disabled: !e.headerProps.nextPeriod,
          class: "nextPeriod",
          "aria-label": "Next Period",
          onClick: c[3] || (c[3] = P((h) => a(e.headerProps.nextPeriod), ["prevent"]))
        }, S(e.nextPeriodLabel), 9, ft),
        b("button", {
          disabled: !e.headerProps.nextYear,
          class: "nextYear",
          "aria-label": "Next Year",
          onClick: c[4] || (c[4] = P((h) => a(e.headerProps.nextYear), ["prevent"]))
        }, S(e.nextYearLabel), 9, mt)
      ]),
      b("div", Dt, [
        C(l.$slots, "label", {}, () => [
          Ye(S(e.headerProps.periodLabel), 1)
        ])
      ])
    ]));
  }
});
export {
  r as CalendarMath,
  ht as CalendarView,
  vt as CalendarViewHeader
};
